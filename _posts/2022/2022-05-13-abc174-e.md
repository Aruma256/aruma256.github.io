---
title: "ABC174 E問題の考え方"
categories:
    - blog
tags:
    - AtCoder
toc: true
---

[ABC174 E問題 - Logs](https://atcoder.jp/contests/abc174/tasks/abc174_e) の考え方を書きました。

# 問題を理解する

* 丸太の本数`N`と、丸太の長さリスト `A = [A_1, A_2, ... , A_N]` が与えられる。
* この丸太を`K`回、分割する。
* かしこく分割することで、「どの丸太も○○メートル以内におさめました！」という状態にしたい。
* 最短で何メートル以内を達成することができるか、出力せよ。

## 例

```python
N = 5
A = [1, 3, 2, 1, 2]
K = 4
```

![example.svg](/assets/2022/2022-05-13-abc174-e/example.svg)

このとき、以下のように丸太を `K=4` 回 分割することで、「どの丸太も `1` メートル以内におさめました！」を達成することができる。

![example_cut.svg](/assets/2022/2022-05-13-abc174-e/example_cut.svg)

これより短くすることはできないので、vこの例では
`1`
と出力すれば正解となる。

## 制約を確認する

|変数名|意味|値の範囲|
|:-:|:-:|:-:|
|N|丸太の本数|1 〜 200000 (2x10<sup>5</sup>)|
|A<sub>i</sub>|丸太の長さ初期値|1 〜 1000000000 (10<sup>9</sup>)|
|K|カット回数|0 〜 1000000000 (10<sup>9</sup>)|

* 答えは小数点以下を切り上げた値で出力すること
* 2秒以内に答えを出力すること

# 解法1（単純な方法・TLE）

「最も長い丸太を選んで、切る回数を増やす」をK回繰り返すと、答えにたどり着く。
プログラム風に記述すると、以下のようになる。（細かい変数は省略）

```ruby
function main() {
    # シミュレーション
    K回繰り返す {
        対象の丸太 = 最も長い丸太を取得()
        対象の丸太.切る回数 += 1
    }
    # 解答
    最長の丸太 = 最も長い丸太を取得()
    print(最長の丸太.長さ)
}

function 最も長い丸太を取得() {
    丸太 A1 〜 AN について {
        長さを確認する
    }
    return 最も長かったもの
}
```

しかし、この実装ではシミュレーション部分の**ループ回数が膨大になってしまう。**

```ruby
K回繰り返す { # 10^9 ループ
    A1 〜 AN について { # 2*10^5 ループ
    }
}
```

この二重ループでは、必ず`N * K`回のループ処理が実行される。
最悪ケース（つまり、N, K どちらも最大値）では
`2*10^5 * 10^9 = 2*10^14 = 200000000000000` 回のループ処理が発生する。

仮に、1GHzのCPUが1クロックにつき1回ループ処理を行えたとしても、
200000秒 ... **2日以上かかってしまう。**

「動作の早いC言語なら...」というレベルではないので、
2秒以内という制約に間に合うよう、アルゴリズムを改善する。

# 解法2（少し工夫・TLE）

`最も長い丸太を取得`という処理は、**優先度付きキュー** を使うと高速に実現できる。（厳密には、平衡2分探索木など）

しかし、そもそも"K回のループ処理"が存在すると2秒以内に収めるのは厳しい。

# 解法3（AC）

発想を転換する。

考え方

1. 答えを一発で求めるのは難しそうだ。
1. 答えを**探索によって**求められないか？
1. 答えは、必ず 0 〜 `max(A)` の範囲内にある
    * 何回分割しても、0にはならない（小数点以下切り上げ）
    * `max(A)` = 初期状態の最大長 は、分割前から達成しているため、確実に達成可能

![ac_step1.svg](/assets/2022/2022-05-13-abc174-e/ac_step1.svg)

「最短で何メートル以内を達成することができるか」ではなく
「Cメートル以内を達成することができるか」ならば、N回以内のループで判定できる。
（Cメートル以内になるように、一括で分割していく）

これを利用して、ちょうど中間地点について、実現可能かを判定してみる。

![ac_step2.svg](/assets/2022/2022-05-13-abc174-e/ac_step2.svg)

答えが存在する範囲のちょうど中間地点について達成可能かを調べ、範囲を狭めていくことを繰り返す。

![ac_step3.svg](/assets/2022/2022-05-13-abc174-e/ac_step3.svg)

可能と不可能の境界を特定できたら、「可能」の点が答えとなる。
ループ回数は `N * log2(max(A))` で、6000000回 程度となる。

||計算量|ループ回数のイメージ|
|-|-|-:|
|解法1|`O(K*N)`|200000000000000 くらい|
|解法2|`O(K*log(N))`|4000000000 くらい|
|解法3|`O(N*log(max(A)))`|6000000 くらい|
