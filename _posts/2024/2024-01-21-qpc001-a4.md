---
title: "QPC001 A4問題で考えたこと"
categories:
    - blog
tags:
    - QCoder
toc: true
---

「Qiskitなんもわからん」状態で [QCoder Programming Contest 001](https://www.qcoder.jp/contests/QPC001) に参加してみました。  
とても楽しく、同じようなわからん状態の方にも参加してみてほしいと思ったので、どのように[A4問題](https://www.qcoder.jp/contests/QPC001/problems/A4)を考えたかをまとめてみます。

# A4問題

A1～A3問題までで、[HGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.HGate)と[XGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.XGate)、及びそれらの制御版である[CHGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CHGate), [CXGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CXGate)というゲートがあることを学びました。  
[A4問題](https://www.qcoder.jp/contests/QPC001/problems/A4)ではこれらのゲートを用いて、ゼロ状態から `|11>` を除くすべての状態を生成するような2量子ビットをもつ量子回路を考えればよさそうです。  
このあとのA5問題では複素振幅まで揃える必要がありますが、A4問題では任意となっています。

問題文には以下のコードが提示されており、この中の `Write your code here:` から `return` までの間を埋めることになります。

```python
from qiskit import QuantumCircuit


def solve() -> QuantumCircuit:
    qc = QuantumCircuit(2)
    # Write your code here:

    return qc
```

## フローを考えた

`|11>` を生成させないためには、状態数が3以下のままとなるようにしようと考えました。  
A4問題では複素振幅は任意なので、

1. `|00>` と `|01>` に分ける
1. `|01>` のみ、 `|01>` と `|11>` に分ける

とすれば、状態数はちょうど3になります。  
今回は `|11>` を生成させたくないので、`|01>` と `|11>` を入れ替えることにします。

![上述の流れの図示](/assets/2024/2024-01-21-qpc001-a4/qpc001_a4.webp)

## 適当なゲートを選んでいく

上述のフローを実現するために、適当なゲートを選んでいきます。

`|00>` を `|00>` と `|01>` に分けるところは、[HGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.HGate)を使えばよいです。
これは、短く

```python
qc.h(0)
```

と書けます。

次の処理は、「`|00>` はそのままで、`|01>` のみ `|01>` と `|11>` に分ける」という制御が必要です。

|input|output|
|---|---|
|`\|00>`|`\|00>`|
|`\|01>`|`\|01>`, `\|11>`|

これは[CHGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CHGate)で実現できます。  
第0量子ビットを制御量子ビット、第1量子ビットをターゲット量子ビットとしてCHGateを適用します。

```python
qc.ch(0, 1)
```

最終段階は、`|00>` と `|10>` はそのままで、`|11>` を `|01>` に変換できればよいです。

|input|output|
|---|---|
|`\|00>`|`\|00>`|
|`\|01>`|`\|01>`|
|`\|11>`|`\|10>`|

これは[CXGate](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CXGate)を使い、第1量子ビットを制御量子ビット、第0量子ビットをターゲット量子ビットとして適用すると実現できます。

```python
qc.cx(1, 0)
```

## 完成したもの

最終的には、以下のようになります。

![上述の流れの図示](/assets/2024/2024-01-21-qpc001-a4/qpc001_a4_gates.webp)

```python
from qiskit import QuantumCircuit


def solve() -> QuantumCircuit:
    qc = QuantumCircuit(2)
    # Write your code here:
    qc.h(0)
    qc.ch(0, 1)
    qc.cx(1, 0)
    return qc
```

## 提出結果

https://www.qcoder.jp/contests/QPC001/submissions/b785b910-d166-438f-8655-e7a183e56b1a

* 結果: AC
* 実行時間: 806 ms
* メモリ: 91 MiB


# さいごに

本当になんもわからん状態で始めたので、[Qiskitのドキュメント](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit) の他、[QCoder推奨の教材リスト](https://www.qcoder.jp/qa)やChatGPTなど様々なものに頼りまくりました。  
大変でしたが、新しいものを学ぶのはわくわくしますね。

量子プログラミングを手軽に始め、自動採点してもらい、Live解説まで聞けるQCoderは、とても良い環境だと思います。  
