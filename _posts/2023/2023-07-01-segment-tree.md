---
title: "Segment Tree の基本"
categories:
    - blog
tags:
    - algorithm
toc: true
---

区間に対するクエリを高速に処理できるデータ構造 Segment Tree（セグメント木）の基本をまとめました。

# なぜ Segment Tree が必要なのか

負荷分散されたサーバー群の使用率を分析する、というストーリーを考えます。  
『ある時刻にbusy状態にあったサーバー台数』のデータをまとめた配列 `arr` があるとします。  
データは1秒ごとの値が全部で1年分、つまり配列のサイズは `60*60*24*365 = 31536000` とします。

* 1月1日 0時0分0秒 のbusyサーバー数: `arr[0]`
* 1月1日 0時0分1秒 のbusyサーバー数: `arr[1]`
* ...

この情報に対する集計クエリを考えます。

## 単一データの取得

例えば20000番目の値なら、`arr[20000]` などで取得できるでしょう。

## 短い区間の合計

あるインデックスから1時間分、つまり `[L, L+60)` の区間の合計を求めたいとします。
これは単純なforループで求めることができますね。

```python
# Python
arr = [i%10 for i in range(31536000)] # ダミーデータ

def range_sum(L):
    _sum = 0
    for i in range(L, L+60):
        _sum += arr[i]
    return _sum
```

`sum(arr[L:L+60])` のように書くこともできますが、こちらも内部的にループ処理が行われているので、本質的には同じことです。

## 長い区間の合計

開始・終了インデックスをどちらも自由に入力できるように拡張することを考えます。  
forループで求めることはできますが、広い区間を指定された場合にはループ回数が多くなり、レスポンスが遅くなってしまうでしょう。  
`[0, 31536000)` のクエリを大量に投げられると、詰まりそうです。

```python
# Python
arr = [i%10 for i in range(31536000)] # ダミーデータ

def range_sum(L, R):
    _sum = 0
    for i in range(L, R): # (R - L) が大きい値の場合、ループ回数が多くなる
        _sum += arr[i]
    return _sum
```

Python実行環境のある方は、インタプリタで上記コードを読み込んでから `range_sum` を実行してみてください。  
`[0, 31536000)` のクエリに対して、どれくらい時間がかかるでしょうか。

ちなみに、この区間の合計を求めるケースでは、累積和を事前に計算しておくことで計算量を改善できます。

```python
# Python
arr = [i%10 for i in range(31536000)] # ダミーデータ

# 事前に累積和を計算しておく（以降のクエリで使い回す）
def preprocess():
    cumulative_sum = [0]
    for val in arr:
        cumulative_sum.append(cumulative_sum[-1] + val)

# 累積和を使って区間の合計を効率よく求める
def range_sum(L, R):
    return cumulative_sum[R] - cumulative_sum[L]
```

## より"難しい"クエリ

ここからは、より難しいクエリを考えてみます。

* `arr` が今後1年分の予測値であり、予測値の更新クエリも受け付けるとしたら？
    * 例えば 50000 番目の時刻にバッチ処理を行うことになったので、その時刻の値を更新する `arr[50000] = 100` というクエリ
        * この場合、**累積和を使った前処理は根本解決にならない** （累積和配列の作り直しが重いため）
* 区間の合計値ではなく最大値（あるいは最小値）が欲しい、となったら？

このような、区間に対する取得のクエリに高速に（`O(N)`よりマシな計算量で）応えられるデータ構造が **Segment Tree** です。

# Segment Tree の概要

Segment Tree は、下記のクエリを高速に（`O(logN)`で）処理できるデータ構造です。

* ある区間 `[L, R)` に対する集計クエリ
* 特定のインデックス `i` に対する更新クエリ

上の例で言えば、予測値の更新や任意区間の最大値取得クエリを O(logN) で処理できる、ということです。

## Segment Tree の発想

毎回合計値を求める方式の問題点は、`[L, R)` が長い区間になるとループ回数が多くなってしまうことでした。

```python
for i in range(L, R):
    val += arr[i]
```
